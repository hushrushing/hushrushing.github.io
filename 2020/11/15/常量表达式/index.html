<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    <link rel="shortcut icon" type='image/x-icon' href="/favicon.ico">


    <!-- meta -->


<title>常量表达式 | TheHushrush</title>


    <meta name="keywords" content="学习">




    <!-- OpenGraph -->
 
    <meta name="description" content="常量表达式1.常量名应该体现其意义 2.常量值不应该经常改变 3.尽可能少用字面常量，尽可能多用符号常量。不能被直接识别的字面常量称为魔术常量 4.常量表达式 4.1常量表达式是仅由常量构成的整型值表达式，在编译期间就可以计算出结果。好处在于        1.允许一些计算只在编译时进行一次，而不是每次程序运行时；　　2.编译器可以进行尺度更大的优化；　　3.可以用在需求编译期间常量的上下文，例如">
<meta property="og:type" content="article">
<meta property="og:title" content="常量表达式">
<meta property="og:url" content="http://hushrushly.github.io/2020/11/15/%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html">
<meta property="og:site_name" content="TheHushrush">
<meta property="og:description" content="常量表达式1.常量名应该体现其意义 2.常量值不应该经常改变 3.尽可能少用字面常量，尽可能多用符号常量。不能被直接识别的字面常量称为魔术常量 4.常量表达式 4.1常量表达式是仅由常量构成的整型值表达式，在编译期间就可以计算出结果。好处在于        1.允许一些计算只在编译时进行一次，而不是每次程序运行时；　　2.编译器可以进行尺度更大的优化；　　3.可以用在需求编译期间常量的上下文，例如">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-15T15:52:07.000Z">
<meta property="article:modified_time" content="2020-11-15T12:41:29.851Z">
<meta property="article:author" content="Hushrush">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">


    
<link rel="stylesheet" href="/css/style/main.css">
 



    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
    

    
    

    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 4.2.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">
                TheHushrush
            </span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">
                        首页
                    </a>
                
                    <a href="/tags/" class="navbar-menu button">
                        标签
                    </a>
                
                    <a href="/archives/" class="navbar-menu button">
                        归档
                    </a>
                
                    <a href="/page/" class="navbar-menu button">
                        Page
                    </a>
                
            </div>
        
        
        

        
        

        

        
            <a class="dropdown-icon button" id="btn-dropdown">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round">
                    <path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path>
                </svg>
            </a>
            <div class="dropdown-menus" id="dropdown-menus">
                <a class="dropback-icon button" id="btn-dropback">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round">
                        <path fill="currentColor" d="M11.469,10l7.08-7.08c0.406-0.406,0.406-1.064,0-1.469c-0.406-0.406-1.063-0.406-1.469,0L10,8.53l-7.081-7.08c-0.406-0.406-1.064-0.406-1.469,0c-0.406,0.406-0.406,1.063,0,1.469L8.531,10L1.45,17.081c-0.406,0.406-0.406,1.064,0,1.469c0.203,0.203,0.469,0.304,0.735,0.304c0.266,0,0.531-0.101,0.735-0.304L10,11.469l7.08,7.081c0.203,0.203,0.469,0.304,0.735,0.304c0.267,0,0.532-0.101,0.735-0.304c0.406-0.406,0.406-1.064,0-1.469L11.469,10z"></path>
                    </svg>
                </a>
                
                    <a href="/" class="dropdown-menu button">
                        首页
                    </a>
                
                    <a href="/tags/" class="dropdown-menu button">
                        标签
                    </a>
                
                    <a href="/archives/" class="dropdown-menu button">
                        归档
                    </a>
                
                    <a href="/page/" class="dropdown-menu button">
                        Page
                    </a>
                
            </div>
            <script>
                document.getElementById('btn-dropdown').addEventListener('click', () => {
                    const dd = document.getElementById('dropdown-menus');
                    requestAnimationFrame(() => {
                        dd.style.display = 'flex';
                        requestAnimationFrame(() => {
                            dd.style.transform = 'translateY(0)';
                            dd.style.opacity = '1';
                        });
                    });
                });
                document.getElementById('btn-dropback').addEventListener('click', () => {
                    const dd = document.getElementById('dropdown-menus');
                    dd.style.transform = 'translateY(2.25rem)';                    
                    dd.style.opacity = '0';
                    setTimeout(() => {dd.style.display = 'none';}, 350);
                });
            </script>
        
    </div>
</header>


            <main class="main">
    
<div class="post-title">
    <h1 class="post-title__text">
        常量表达式
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2020/11/" class="post-meta__date button">
    2020-11-15
</a>
        
    <span class="separate-dot"></span><a href="/categories/%E5%AD%A6%E4%B9%A0/" class="button">学习</a>

 
        
    
    


 

 
    </div>
</div>


    <article class="post content-card">
        <div class="post__header"> </div>
        <div class="post__content">
            <h1 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h1><p>1.常量名应该体现其意义</p>
<p>2.常量值不应该经常改变</p>
<p>3.尽可能少用字面常量，尽可能多用符号常量。不能被直接识别的字面常量称为魔术常量</p>
<p>4.常量表达式</p>
<p>4.1常量表达式是仅由常量构成的整型值表达式，在编译期间就可以计算出结果。好处在于        1.允许一些计算只在编译时进行一次，而不是每次程序运行时；<br>　　2.编译器可以进行尺度更大的优化；<br>　　3.可以用在需求编译期间常量的上下文，例如数组长度等；</p>
<p>4.2举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">17</span>;<span class="comment">//字面常量，是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">19</span>;</span><br><span class="line"><span class="built_in">max</span>+<span class="number">2</span>;<span class="comment">//是常量表达式</span></span><br><span class="line">val+<span class="number">2</span>;<span class="comment">//不是常量表达式，有变量val</span></span><br></pre></td></tr></table></figure>

<p>4.3constexpr和const</p>
<p>4.3.1const 是对变量的一个修饰，告诉编译器这个变量只能被初始化且不能修改（可以通过堆栈溢出等方式修改），初始化可以延迟到运行时。</p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">int</span> c1=<span class="built_in">max</span>+<span class="number">7</span><span class="comment">//正确，c1是107，c1是常量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c2=n+<span class="number">7</span><span class="comment">//正确，n还不知道，但是编译的时候就知道了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.3.2constexpr</p>
<p>4.3.2.1constexpr修饰变量时，变量必须在编译时就被初始化。所有constexpr对象都是const的，但是不是所有的const对象都是constexpr的。</p>
<p>4.3.2.2constexpr修饰函数（见引用段落）</p>
<blockquote>
<p>（以下见<a href="https://www.cnblogs.com/lizhanzhe/p/10901768.html）" target="_blank" rel="noopener">https://www.cnblogs.com/lizhanzhe/p/10901768.html）</a></p>
<p>constexpr函数限制持有和返回的类型为字面值类型（literal type），本质上就是一些在编译期间可确定值的类型。在C++中，除了void之外的内置类型都是字面值类型，不过用户定义的类型也有可能是字面值类型，因为构造函数和其他成员函数可能是constexpr的；<br>　如果实参都是常量表达式的话，那么它可以在编译时产生返回值；其它情况下，常量表达式函数跟普通函数一样，只有在运行时才能被调用，产生返回值；</p>
<p><strong>对constexpr函数的基本要求：</strong></p>
<ol>
<li>常量表达式函数必须有返回值（不可以是void函数）</li>
<li>常量表达式函数体中只能有一条语句，且该语句必须是return语句。（可以使用?:、递归）但不产生实际代码的语句可以在常量表达式函数中使用，如static_assert,using,typedef等（这条规定在C++14中大幅放松）</li>
<li>return语句中，不能使用非常量表达式的变量、函数，且return的表达式也要是常量表达式</li>
<li>常量表达式函数在使用前，必须有定义。（普通函数在被调用前只要有函数声明就够了，不一定有定义）</li>
</ol>
<p><strong>常量构造函数的要求：</strong></p>
<ol>
<li>成员变量只能通过初始化列表来初始化，函数体必须为空</li>
<li>初始化列表只能由常量表达式来赋值</li>
</ol>
<p><strong>常量成员函数的要求：</strong></p>
<ol>
<li>常量成员函数被隐式定义为const成员函数，不可以通过常量成员函数去修改成员变量。也就是说，常量成员函数往往是所谓的getter函数。（c++14则不同，允许constexpr成员函数去修改成员变量）</li>
<li>常量成员函数不能是virtual的</li>
</ol>
<p><strong>在C++11与C++14的区别：</strong><br>　　在C++11标准中，对于constexpr修饰的函数给了及其苛刻的限定条件：函数的返回值类型及所有形参的类型都是字面值类型，而且函数体内必须有且只有一条return语句。这个条件显然是太苛刻了，以至于很多在constexpr的操作都要借助？：表达式，递归等办法实现。在C++14中，放宽了这一限定，只保留了“函数的返回值类型及所有形参的类型都是字面值类型”，也就是说，这些值都在编译期能确定了就行。</p>
<h3 id="constexpr与const的本质区别"><a href="#constexpr与const的本质区别" class="headerlink" title="constexpr与const的本质区别"></a>constexpr与const的本质区别</h3><p>　　<strong>const</strong>主要用于表达“对接口的写权限控制”，即“对于被const修饰的量名(例如const指针变量)，不得通过它对所指对象作任何修改”。(但是可以通过其他接口修改该对象)。另外，把对象声明为const也为编译器提供了潜在的优化可能。具体来说就是，如果把一个量声明为const，并且没有其他地方对该量作取址运算，那么编译器通常(取决于编译期实现)会用该量的实际常量值直接替换掉代码中所有引用该量的地方，而不用在最终编译结果中生成对该量的存取指令。<strong>constexpr</strong>的主要功能则是让更多的运算可以在编译期完成，并能保证表达式在语义上是类型安全的。(译注：相比之下，C语言中#define只能提供简单的文本替换，而不具任何类型检查能力)。与const相比，被constexpr修饰的对象则强制要求其初始化表达式能够在编译期完成计算。之后所有引用该常量对象的地方，若非必要，一律用计算出来的常量值替换。</p>
<h3 id="能否同时使用constexpr与const"><a href="#能否同时使用constexpr与const" class="headerlink" title="能否同时使用constexpr与const?"></a>能否同时使用constexpr与const?</h3><p>　　对于变量来讲，一般情况下constexpr已经包含了const的语义，所以没必要同时使用；但是也有特殊情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static constexpr int N &#x3D; 3;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  constexpr const int *NP &#x3D; &amp;N;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在这里const和constexpr在修饰不同的东西，constexpr和const都必须要有。constexpr表示NP指针本身是常量表达式，而const表示指向的值是一个常量。去掉const之后无法编译，因为不能用正常指针指向常量。对于成员函数来讲，在C++11中constexpr同样包含const的含义，但是C++14中则不，所以C++14中可能会需要同时使用const与constexpr。</p>
</blockquote>

        </div>
         
        <div class="post-footer__meta">
    <p>
        更新于 2020-11-15
    </p>
</div> 
        <div class="post-meta__cats">
    
        <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="post-cats__link button">学习</a>
    
    
        <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="post-tags__link button"># 学习</a>
    
</div> 
    </article>
    


</main>

            <footer class="footer">
    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright&nbsp;©&nbsp;2020&nbsp;-&nbsp;2020&nbsp;<a href="/">TheHushrush</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
        
    <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
    <script>
        window.lazyLoadOptions = {
            elements_selector: ".lazyload",
            threshold: 0
        };
    </script>
 

 

 

 
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement('script');
            hm.src = 'https://hm.baidu.com/hm.js?fe1d9d2dc48a2ab8ea7f292f05e237cd';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
 

  



 


    


 




    <script>
        if (typeof MathJax === 'undefined') {
            window.MathJax = {
                loader: {
                    source: {
                        '[tex]/amsCd': '[tex]/amscd',
                        '[tex]/AMScd': '[tex]/amscd'
                    }
                },
                tex: {
                    inlineMath: {'[+]': [['$', '$']]},
                    tags: 'ams'
                },
                options: {
                    renderActions: {
                        findScript: [10, doc => {
                            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                                const display = !!node.type.match(/; *mode=display/);
                                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                                const text = document.createTextNode('');
                                node.parentNode.replaceChild(text, node);
                                math.start = {node: text, delim: '', n: 0};
                                math.end = {node: text, delim: '', n: 0};
                                doc.math.push(math);
                            });
                        }, '', false],
                        insertedScript: [200, () => {
                            document.querySelectorAll('mjx-container').forEach(node => {
                                let target = node.parentNode;
                                if (target.nodeName.toLowerCase() === 'li') {
                                    target.parentNode.classList.add('has-jax');
                                }
                            });
                        }, '', false]
                    }
                }
            };
            (function () {
                var script = document.createElement('script');
                script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
                script.defer = true;
                document.head.appendChild(script);
            })();
        } else {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
        }
    </script>





    </body>
</html>
